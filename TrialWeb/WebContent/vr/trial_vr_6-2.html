<!--
    Three.jsで作るWebVRの操作面について考える【注視点カーソル】
    https://cardboardclub.jp/lab/ctrl-cursor/

    [メモ]
    - 上記URLのページのソースを改造
      - Cubeは動かないで固定とする
      - html/jsを1つのhtmlファイルにまとめる
    - デバイスの視点に追従しないが、ドラックすれば動く
      - ⇒ Androidはhttpsにすることでデバイスに追従
           iOS13以後はhttpsに加えて、DeviceOrientationEvent.requestPermission()によって追従するようになる
    - 注視点上の図形が拡大しない時があるので位置がずれている
      - ⇒ r113では"cursor-l", "cursor-r"のmarginは不要
    - Androidの場合は「センサー有効化」のボタンは表示しないで最初から実行
    - 「センサー有効化」の直後は位置がずれてしまうのでオフセットを付ける
      - https://tknc.jp/tp_detail.php?id=841
      - ただ、上記のサンプルはDeviceOrientationControlsのみを使っている。
      　一方、こちらのソースはOrbitControlsからDeviceOrientationControlsに切り替えているため、
      　オフセット値の取得方法は初回のデバイスからの値としている。(isFirstDeviceValueフラグの使用)
-->
<html>
<head>
  <meta charset="UTF-8">
  <meta name="keywords" content="">
  <meta name="description" content="">
  <title>webVRサンプル｜localテスト</title>
  <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="IE=edge"/>

  <style>
<!--
    *{
      margin: 0;
      padding: 0;
    }
    #base{
      position: absolute;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: -1;
    }
    #world {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
    }
    #cursors{
      position: absolute;
      display: table;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 10;
    }
    #cursors .cursor{
      position: absolute;
      width: 0;
      height: 0;
      top: 50%;
    }
    #cursors .cursor-l{
      left: 25%;
      /* margin-left: -25px; */
      border: medium solid #000
    }
    #cursors .cursor-r{
      right: 25%;
      /* margin-right: -25px; */
      border: medium solid #000
    }

    #cursors .cursor .dot{
      position: relative;
      width: 10px;
      height: 10px;
      margin-top: -5px;
      margin-left: -5px;
      border-radius: 50%;
      background: #f00;
      opacity: 0.5;
    }
    #log {
      position: absolute;
      top: 100px;
    }
    #btn-permission {
      position: absolute;
      bottom: 100px;
      z-index: 100;
    }
-->
  </style>

<!-- Three.js r73を利用 （オリジナルと同じバージョン ) -->
<script src="https://code.jquery.com/jquery-1.11.1.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/build/three.min.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/examples/js/controls/OrbitControls.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/examples/js/controls/DeviceOrientationControls.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/examples/js/effects/StereoEffect.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/examples/js/Detector.js"></script>
<script type="text/javascript" src="https://unpkg.com/three@0.90.0/examples/js/libs/stats.min.js"></script>

<script type="text/javascript">
  var container;
  var camera, scene, renderer, element, controls;
  var camera_dev;
  var rotate_offset_x, rotate_offset_y, rotate_offset_z;
  var rotate_offset_dev_x, rotate_offset_dev_y, rotate_offset_dev_z;
  var selectedId = -1;
  var isFirstDeviceValue = true;

  var group;
  var baseColor=0xffffff;

  //THREE.Raycaster用
  var raycaster,scopedObj;
  var cursor= new THREE.Vector2(0,0);
  
  $(function() {
    if ( ! Detector.webgl ){
      Detector.addGetWebGLMessage();
    }else{
      init();
      animate();
    }
  });
  
  function init(){
    scene = new THREE.Scene();
    container = document.getElementById('world');
  
    camera = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 10000 );
    camera.position.z = 2000;

    renderer = new THREE.WebGLRenderer({ alpha: true });
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setClearColor(baseColor);
    container.appendChild( renderer.domElement );

    /* 注視点の処理をするTHREE.Raycaster */
    raycaster = new THREE.Raycaster();    

    /* Light */
    ambLight = new THREE.AmbientLight( 0xffffff, 0.5 );
    scene.add( ambLight );
    dirLight = new THREE.DirectionalLight( 0xffffff, 1 );
    dirLight.position.set( 1,1,1 );
    scene.add( dirLight );

    /* センサーリスナの初期化 */
    if( window.DeviceOrientationEvent ){
      /* iOS13 以上であれば DeviceOrientationEvent.requestPermission 関数が定義されているので、ここで条件分岐 */
      if( DeviceOrientationEvent.requestPermission && typeof DeviceOrientationEvent.requestPermission === 'function' ){
        /* iOS 13 以上の場合は「センサー有効化」ボタンを追加 */
        var permissionBtn = document.getElementById("btn-permission");
        permissionBtn.addEventListener("click", requestDevicePermission, false);
      } else{
        /* Android または iOS 13 未満の場合は"deviceorientation"リスナを追加 */
        /* deviceorientation イベント発生時に setOrientationControls 関数がハンドリングするよう登録 */
        window.addEventListener( "deviceorientation", setOrientationControls, true );
      }
    }

    /* マウス操作イベント */
    controls = new THREE.OrbitControls(camera);
    //[trial] このAPIはTheee.js r72には無い
    //controls.rotateUp(Math.PI / 4);
    controls.target.set(
      camera.position.x + 0.1,
      camera.position.y,
      camera.position.z + 1
    );
    controls.noZoom = true;
    controls.noPan = true;
  
    //両眼カメラレンダリング
    effect = new THREE.StereoEffect( renderer );
    effect.setSize(window.innerWidth, window.innerHeight);
    effect.eyeSeparation = 10;
  
    /* 描画状態の表示 */
    stats = new Stats();
    stats.domElement.style.position = 'absolute';
    stats.domElement.style.top = '50px';
    container.appendChild( stats.domElement );
    
    /* 奥の図形を霞ませるfog効果 */
    scene.fog = new THREE.Fog( baseColor, 500, cubeAreaSize );

    /* ウインドウリサイズ時のイベント処理 */
    window.addEventListener( 'resize', resize, false );
    setTimeout(resize, 1);
    
    /* サンプル図形の生成 */
    makeCubes();
  }

  /* ジャイロに切り替え */
  function setOrientationControls(e) {
    /* 「センサー有効化」ボタンは不要なので消す */
    document.getElementById("btn-permission").remove();
    resize();

    /* デバイスのジャイロ角度が取得できないのはPCの場合 */
    log('alpha:' + e.alpha);
    log('beta:' + e.beta);
    log('gamma:' + e.gamma);
    if (!e.alpha) {
      log("Not supported orientation controls")
      return;
    }

    /* DeviceOrientationControl用のカメラを作成 */
    camera_dev = new THREE.PerspectiveCamera( 90, window.innerWidth / window.innerHeight, 1, 10000 );
    //jQuery.extend(true, camera_dev, camera)
    camera_dev.position.x = camera.position.x;
    camera_dev.position.y = camera.position.y;
    camera_dev.position.z = camera.position.z;

    /* ジャイロ角度を取得できているので操作方法もジャイロに変更 */
    controls = new THREE.DeviceOrientationControls(camera_dev, true);
    controls.connect();
    controls.update();
    /* ジャイロ開始時の値をオフセットとして取得 */
// ただ、ここで取得しても値が不正のためisFirstDeviceValueにて初回の値を利用
//    rotate_offset_x = camera.rotation.x;
//    rotate_offset_y = camera.rotation.y;
//    rotate_offset_z = camera.rotation.z;
//    rotate_offset_dev_x = camera_dev.rotation.x;
//    rotate_offset_dev_y = camera_dev.rotation.y;     // ⇒この時だと-1.57 (-PI/2)になってしまう
//    rotate_offset_dev_z = camera_dev.rotation.z;

    /* THREE.DeviceOrientationControlsでリスナを追加しているので、ここでは除去する　*/
    window.removeEventListener('deviceorientation', setOrientationControls, true);
    log ("Remove deviceorientation listener")
  }

  function requestDevicePermission() {
      /*. iOS 13 以上の場合 */
      /* ユーザーに「許可」を求めるダイアログを表示 */
      DeviceOrientationEvent.requestPermission().then( function( response ){
        log("ClickRequestDeviceSensor: Response: " + response);
        if( response === 'granted' ){
          /* 許可された場合のみイベントハンドラを追加できる */
          window.addEventListener( 'deviceorientation', setOrientationControls, true );
        }
      });
  }
  
  /* デバック用にログ表示　*/
  function log(msg, clear) {
    var logDiv = document.getElementById("log");
    if (clear) {
      logDiv.innerHTML = "";  
    }
    logDiv.innerHTML += (msg + "<br/>");
  }
  
  function resize() {
    var width = window.innerWidth;
    var height = window.innerHeight;
    camera.aspect = width / height;
    camera.updateProjectionMatrix();
    renderer.setSize( width, height );
    effect.setSize( width, height );
  }
  
  function update(){
    cubeUpdate();
  }
  function render() {
    controls.update();
    /* Effect内で実施しているためrendererはコメントアウト */
    //renderer.render( scene, camera );
    effect.render( scene, camera );
 
    /* 注視点に乗っているオブジェクトを取得 */
    raycaster.setFromCamera( cursor, camera );
    var intersects = raycaster.intersectObjects( group.children );
    if ( intersects.length > 0 ) {
      if ( scopedObj != intersects[ 0 ].object ) {
        if ( scopedObj ) scopedObj.scale.set(1,1,1);
        scopedObj = intersects[ 0 ].object;
        scopedObj.scale.set(2,2,2);
        selectedId = scopedObj.id;
      }
    } else {
      if ( scopedObj ) scopedObj.scale.set(1,1,1);
      scopedObj = null;
    }

    if (camera_dev) {
      var rotate_dev_x=camera_dev.rotation.x;
			var rotate_dev_y=camera_dev.rotation.y;
			var rotate_dev_z=camera_dev.rotation.z;

      if (isFirstDeviceValue) {
        /* 初回にデバイスから取得したデータをオフセットとする */
        rotate_offset_x = camera.rotation.x;
        rotate_offset_y = camera.rotation.y;
        rotate_offset_z = camera.rotation.z;
        rotate_offset_dev_x = rotate_dev_x;
        rotate_offset_dev_y = rotate_dev_y;
        rotate_offset_dev_z = rotate_dev_z;
        isFirstDeviceValue = false; 
      }


      log("position:" + camera.position.x.toFixed(2) + ", " + camera.position.y.toFixed(2) + ", " + camera.position.z.toFixed(2), true);
      log("position_dev:" + camera_dev.position.x.toFixed(2) + ", " + camera_dev.position.y.toFixed(2) + ", " + camera_dev.position.z.toFixed(2));
      log("rotate_offset:" + rotate_offset_x.toFixed(2) + ", " + rotate_offset_y.toFixed(2) + ", " + rotate_offset_z.toFixed(2));
      log("rotate_offset_dev:" + rotate_offset_dev_x.toFixed(2) + ", " + rotate_offset_dev_y.toFixed(2) + ", " + rotate_offset_dev_z.toFixed(2));
      log("rotate_dev:" + rotate_dev_x.toFixed(2) + ", " + rotate_dev_y.toFixed(2) + ", " + rotate_dev_z.toFixed(2));
      log("selected: " + selectedId);

      /*
       * ジャイロから取得した値を描画用のカメラに設定
       * 
       * オフセット値を考慮する。
       * ジャイロ値のオフセット値を引き算して、「センサー有効化」前の値は足し算となる
       */
      camera.rotation.x=(rotate_dev_x - rotate_offset_dev_x + rotate_offset_x);
      camera.rotation.y=(rotate_dev_y - rotate_offset_dev_y + rotate_offset_y);
      camera.rotation.z=(rotate_dev_z - rotate_offset_dev_z + rotate_offset_z);

      log("rotate_adjusted:" + camera.rotation.x.toFixed(2) + ", " + camera.rotation.y.toFixed(2) + ", " + camera.rotation.z.toFixed(2));
    }
    else {
      log("position:" + camera.position.x.toFixed(2) + ", " + camera.position.y.toFixed(2) + ", " + camera.position.z.toFixed(2), true);
      log("rotate:" + camera.rotation.x.toFixed(2) + ", " + camera.rotation.y.toFixed(2) + ", " + camera.rotation.z.toFixed(2));
      log("selected: " + selectedId);
    }


  }
  function animate() {
    requestAnimationFrame( animate );
    //[trial] Cubeは動かないようにする
    //update();
    render();
    stats.update();
  }
  
  
  /* CUBEの作成 */
  var cubeColors=[
    0x3369e8,
    0xd50f25,
    0xeeb211,
    0x009925
  ];
  var cubes=[],
  cubeCnt=300,
  cubeSizeBase=100,
  cubeSizeRnd=300,
  cubeAreaSize=12000;
  
  function makeCubes(){
    group = new THREE.Group();
    scene.add( group );
    for(var i=0;i<cubeCnt;i++){
      var cube=new Cube();
      group.add(cube.obj);
      cubes.push(cube);
    }
  }
  
  function cubeUpdate(){
    for(var i=0; i<cubes.length; i++){
      cubes[i].update();
    }
  }
  
  var Cube=function() {
    var size=Math.random()*cubeSizeRnd+cubeSizeBase;
    this.geometry=new THREE.BoxGeometry( size, size, size );
    this.material=new THREE.MeshPhongMaterial({color:cubeColors[Math.floor(Math.random()*cubeColors.length)]});
    this.obj=new THREE.Mesh( this.geometry, this.material );
    this.obj.position.x=Math.random()*cubeAreaSize-cubeAreaSize/2;
    this.obj.position.y=Math.random()*cubeAreaSize-cubeAreaSize/2;
    this.obj.position.z=camera.position.z+(Math.random()*cubeAreaSize*2-cubeAreaSize);
    this.obj.rotation.x=Math.random()*2*Math.PI;
    this.obj.rotation.y=Math.random()*2*Math.PI;
    this.zSpeed=-(Math.random()*100+50);
    this.rSpeedX=Math.random()*0.2-0.1;
    this.rSpeedY=Math.random()*0.2-0.1;
  };
  Cube.prototype={
    update:function(){
      if(this.obj.position.z<camera.position.z-cubeAreaSize-1000){
        this.obj.position.z=camera.position.z+cubeAreaSize;
        this.obj.position.x=Math.random()*cubeAreaSize-cubeAreaSize/2;
        this.obj.position.y=Math.random()*cubeAreaSize-cubeAreaSize/2;
      }
      this.obj.position.z+=this.zSpeed;
      this.obj.rotation.x+=this.rSpeedX;
      this.obj.rotation.y+=this.rSpeedY;
    }
  };
  </script>

</head>



<body>
  <div id="base">
    <div id="world">
      <div id="cursors">
        <div class="cursor cursor-l"><p class="dot"></p></div>
        <div class="cursor cursor-r"><p class="dot"></p></div>
      </div>    
    </div>
    <div id="log"></div>
  </div>
  <button type="button" id="btn-permission">センサー有効化</button>
</body>

</html>